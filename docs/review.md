## 미션 수행의 과정

---

처음 레포를 포크하고 boilerplate를 마주했을 때 Lotto 클래스를 보고 드디어 클래스를 다시 한번 공부해야겠다는 생각이 들었다. 대략적으로 constructor가 뭐고 method와 state를 알았는데 #numbers 라는 private field를 처음봐서 순간 멍했다. 클래스에 이런 것이 있었나? 처음에는 underscore(_) 처럼 컨벤션처럼 사용하는 것이라고 생각했는데 이리저리 만져보니 클래스 바깥에서 접근이 불가해서 놀랐다. 공부해보니 아직 공식적인 문법은 아니지만 최신 브라우저에서 거의 다 지원을 하는 것 같았다. 덕분에 다시 한번 클래스를 공부하고 정리해볼 수 있었다.

클래스를 공부하고 본격적인 구현을 하기 위해 다시 한번 코드를 봤다. 이제부터는 boilerplate의 코드가 이렇게 주어진 이유에 대해서 생각하기 시작했다. Lotto와 App에는 어떤 로직들이 들어가야 맞을지, numbers가 private field로 주어진 이유는 무엇일지, Lotto라는 클래스는 하나의 Lotto를 의미하는건데 왜 constructor에 numbers라는 인자를 받을지 등에 대한 질문이 이어졌다. 아직 정확히 어떤 이유에서 해당 코드가 주어졌는지 모르겠지만 고민하는 시간이 무의미하다고는 생각하지 않는다. 코드에는 정답이 없다는 것을 다시 한번 느꼈고 해당 boilerplate 코드가 무조건적인 정답이 아니라는 것도 알고 있다. 그래서 나라면 어떻게 짰을까 하면서 코드를 스스로 처음부터 스스로 짜보기도 하면서 좀 가지고 놀아봤다. 

위와 같은 고민을 하면서  바로 구현에 들어가지 못했다. 커밋을 매일 날려야 한다는 부담감이 있어서 내가 이렇게 코드를 짜기도 전에 먼저 고민하는 것이 좋은건지 모르겠다는 생각이 계속 들었다. 첫 코드부터 완벽해야 한다는 강박관념 때문에 두려워서 코드에 손을 못대고 있는건 아닌지라는 의심도 들었다. 그러다가 구글에 엔지니어가 자기는 코드를 짜는 시간은 정말 짧은데 그 전까지의 과정이 오래 걸린다는 말이 갑자기 생각이 났다. 합격하고 싶다는 욕심이 나를 조급하게 만들지만 무작정 코드를 치기전에 생각을 깊게 하는 방법도 배우자라는 생각이 들었다.

## 배운 것

---

- 클래스
    
    [Javascript Class](https://liberating-piper-f2b.notion.site/Javascript-Class-8caf7c70621d407796c60ecafd5e1d5b)
    
- getter & setter
    
    [Getter / Setter in Object](https://liberating-piper-f2b.notion.site/Getter-Setter-in-Object-e700d487814a494eb498396a34cf4f5e)
    

## 했던 고민

---

- string input → number 변환 및 validation
    
    모든 입력값은 숫자이더라도 문자로 들어온다. 처음에 코드를 작성했을 때는 무조건 앞에 + 를 붙였는데 그렇게 하다보니 NaN인데도 typeof를 이용한 타입체킹에서 number라고 인식을 했다. 또한 입력값에 소수, 음수, 공백, 특수문자 등이 들어올 수 있는 상황인데 갑자기 +를 이용하는 것과 Number을 이용하는 것의 차이가 궁금해졌다. 아래 이미지를 보고 내가 원하는 결과는 무엇일지 생각해보았다. 그래서 결론적으로는 + 와 parseInt를 두개 다 사용해서 체킹을 하고 반환값에는 + 를 사용하였다. 또한 모든 입력값이 숫자로 변환되는 과정을 거쳐야 하기 때문에 통일성과 재사용을 위해 별도의 함수로 분리하였다.
    
    [](https://i.stack.imgur.com/LLrgj.png)
    
- Lotto와 App에 로직 분리
    
    위에서도 언급하였지만 Lotto와 App에 어떤 메소드와 state를 넣을지 고민을 많이 했다. 
    
- readline synchronous
    
    MissionUtils의 Console을 이용해서 readline을 구현하고 있는데 해당 작업이 비동기적으로 실행이 되어서 저번주부터 계속 로직을 짜는데 걸림돌이 되고있다. readline을 synchronous로 해주는 라이브러리가 있어서 소스코드를 구경했는데 도저히 읽을 수가 없어서 포기했다. 콜백의 맨 마지막에 다음에 실행할 함수를 호출하는데 메소드마다 의존성이 생겨서 좋은 코드라고 할 수 없다는 생각이 들었다. 하지만 아직까지 해결책을 찾지 못해서 추후 리팩토링 과정에서 다시 한번 진행해봐야할 것 같다. 저번주차에 Promise로 감싸서 async/await 문법을 이용했는데 test code가 실행이 안되는 문제가 있어서 이번주차에는 아예 시도도 하지 않았었다. 미션 제출후에 다시 한번 Promise와 async/await을 이용해서 구현 해보는 것도 도전해보려고 한다.
    
- 함수의 분리와 모듈화는 어디까지
    
    아래 리팩토링 방향성에서 좀 더 자세히 설명한다.
    
- 테스트 코드는 어디까지
    
    테스트 코드는 예외처리용으로만 몇개 추가를 해보는데 그쳤다. mock data를 입력하고 예상 결과를 체크하는데 그쳐서 조금 더 심도있는데 테스트 코드를 추가해보고 싶다. 또한 예외처리 외에 어떤 상황을 테스트 코드로 작성하는지도 좀 더 공부가 필요하다. 
    

## 리팩토링 방향성

---

- App의 로직 모듈화 고민
    
    App의 경우 크게 입력값을 받거나, 결과를 도출하거나, 결과를 출력하는 메소드, validation 메소드로 구성되어있다. 각각의 카테고리들은 통일성을 주기 위해서 메소드 이름 앞에 동사를 동일하게 사용해주었다. 
    정리를 하면 아래와 같았다.
    
    - 입력값을 받는 메소드 : getPayment, getWinningNumber, getBonusNumber
    - 결과를 도출하는 메소드 : generateLottos, generateResult, generateProfitRate
    - 결과를 출력하는 메소드: printPurchaseQuantity, printLottos, printResult, printProfitRate
    - validation 메소드 : validatePayment, validateWinningNumber, validateBonusNumber
    
    App은 로또를 사는 것부터 결과를 얻는 것까지의 과정이 담기는 클래스라고 생각하여 코드를 모두 클래스안에 넣어놨는데 같은 성격의 메소드끼리 별도의 파일로 분리하는 것도 좋을 것 같다는 생각이 들었다. 
    
    하지만 그전에 해결할 것은 현재 readline의 비동기적 실행으로 인해 각각의 callback안에 다음에 실행해야할 메소드를 지정해주고 있는데 이는 별도의 파일로 분리했을 때 해당 메소드들을 다시 import해야하는 번거로움이 생긴다. 또한 파일들간의 의존성이 생기면 테스트를 하기도 힘들어질 것 같아서 이 부분의 해결이 먼저 우선시 되어야 할 것 같다.
    

- 테스트 코드의 모듈화
    
    아직 테스트 코드에 대한 이해가 부족하다는 생각이 많이 들었다. 예외처리에 대한 테스트 코드를 추가했지만 이것 또한 연관성이 있는 것끼리 모듈화가 필요하다는 생각이 들었다. 그래야지 테스트 코드가 많아졌을 때 핸들링하기 더 쉬울 것 같다.